\documentclass[bachelor, zaoch, coursework]{SCWorks}
% параметр - тип обучения - одно из значений:
%    spec     - специальность
%    bachelor - бакалавриат (по умолчанию)
%    master   - магистратура
% параметр - форма обучения - одно из значений:
%    och   - очное (по умолчанию)
%    zaoch - заочное
% параметр - тип работы - одно из значений:
%    referat    - реферат
%    coursework - курсовая работа (по умолчанию)
%    diploma    - дипломная работа
%    pract      - отчет по практике
%    pract      - отчет о научно-исследовательской работе
%    autoref    - автореферат выпускной работы
%    assignment - задание на выпускную квалификационную работу
%    review     - отзыв руководителя
%    critique   - рецензия на выпускную работу
% параметр - включение шрифта
%    times    - включение шрифта Times New Roman (если установлен)

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal
%               по умолчанию выключен
\usepackage[T2A]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{graphicx}

\usepackage[sort,compress]{cite}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{longtable}
\usepackage{array}


% Custom colors
\usepackage{color}
\usepackage{xcolor}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}

\usepackage[english,russian]{babel}


\usepackage[colorlinks=true]{hyperref}


% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}}


% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}

\newcommand{\eqdef}{\stackrel {\rm def}{=}}

\newtheorem{lem}{Лемма}

\begin{document}

% Кафедра (в родительном падеже)
\chair{математической кибернетики и компьютерных наук}

% Тема работы
\title{Алгоритмы консенсуса. Raft}

% Курс
\course{4}

% Группа
\group{451}

% Факультет (в родительном падеже) (по умолчанию "факультета КНиИТ")
%\department{факультета КНиИТ}

% Специальность/направление код - наименование
%\napravlenie{02.03.02 "--- Фундаментальная информатика и информационные технологии}
%\napravlenie{02.03.01 "--- Математическое обеспечение и администрирование информационных систем}
%\napravlenie{09.03.01 "--- Информатика и вычислительная техника}
\napravlenie{09.03.04 "--- Программная инженерия}
%\napravlenie{10.05.01 "--- Компьютерная безопасность}

% Для студентки. Для работы студента следующая команда не нужна.
\studenttitle{Студентки}

% Фамилия, имя, отчество в родительном падеже
\author{Ахмановой Элины Дамировны}

% Заведующий кафедрой
\chtitle{к.\,ф.-м.\,н.} % степень, звание
\chname{С.\,В.\,Миронов}

%Научный руководитель (для реферата преподаватель проверяющий работу)
\satitle{к.\,ф.-м.\,н.} %должность, степень, звание
\saname{С.\,В.\,Миронов}

% Руководитель практики от организации (только для практики,
% для остальных типов работ не используется)
%\patitle{к.\,ф.-м.\,н., доцент}
%\paname{Д.\,Ю.\,Петров}

% Семестр (только для практики, для остальных
% типов работ не используется)
%\term{2}

% Наименование практики (только для практики, для остальных
% типов работ не используется)
%\practtype{учебная}

% Продолжительность практики (количество недель) (только для практики,
% для остальных типов работ не используется)
%\duration{2}

% Даты начала и окончания практики (только для практики, для остальных
% типов работ не используется)
%%\practFinish{14.07.2016}

% Год выполнения отчета
\date{2018}

\maketitle

% Включение нумерации рисунков, формул и таблиц по разделам
% (по умолчанию - нумерация сквозная)
% (допускается оба вида нумерации)
%\secNumbering


\tableofcontents

% Раздел "Обозначения и сокращения". Может отсутствовать в работе
%\abbreviations

% Раздел "Определения". Может отсутствовать в работе
%\definitions

% Раздел "Определения, обозначения и сокращения". Может отсутствовать в работе.
% Если присутствует, то заменяет собой разделы "Обозначения и сокращения" и "Определения"
%\defabbr


% Раздел "Введение"
\intro

	% Мир распределённых вычислений
	Развитие человека как вида непосредственно связано с увеличением размера социальных групп. Многие люди не могут представить себя как отшельника или участника закрытой общины на 50 человек. Эволюция \\компьютерных систем имеет похожую историю: монолитные однопроцессорные системы уходят в прошлое, уступив место гибким масштабируемым \\ распределённым системам. 
	
	Особенно остро изменения в многопоточных и распределённых системах ощущаются с распространением микропроцессорной технологии (как итог компьютеры стали более мощными и дешёвыми), ростом использования сети Интернет и увеличением скорости обмена информацией.  Это повлияло на нарастание привлекательности горизонтального масштабирования распределённых систем (увеличения числа узлов) вместо вертикального (замена устройств на более мощные). 

	Несмотря на общую дешевизну и простоту увеличения числа узлов, горизонтельное масштабирование нуждается в строгой системе управления распределёнными вычислениями между большим числом узлов. Узлы в \\ управляемой системе должны либо состоять в строгой иерархии, либо поддерживать консенсус равноправных элементов.  
	
	Алгоритмы консенсуса являются одним из способов организации сообщения узлов в децентрализованных распределённых системах. Эти алгоритмы лежат в основе разработки банковских систем [Distributed Online Banking Mahmood Akhtar], баз данных [Big table], болкчейн систем [mastering blockchain] и пр.
	
 В данной работе основное внимание будет посвящено именно алгоритмам консенсуса, и, в частности, алгоритму Raft. Цель работы: изучить алгоритмы консенсуса и реализовать распределённую систему с помощью алгоритма Raft. 
 
 Задачи работы: 
 \begin{itemize}
 	\item изучить модель логических часов;
 	\item выделить особенности основных алгоритмов консенсуса;
 	\item реализовать распределённую, реплицированную, устойчивую к \\ непредвиденным сбоям систему с помощью алгоритма Raft.
\end{itemize}  

 В первой части будут рассмотрены теоретические понятия логических часов, консенсуса; также будет рассмотрены модель логических часов Лампорта и особенности алгоритмов консенсуса. Мы постараемся объяснить, чем был обусловлен выбор алгоритма Raft для последующей реализации. 
 
 Во второй части будет реализована распределённая система и предложена базовая реализация для принятия решения несколькими узлами с учётом возможных сбоев сети (уменьшение скорости передачи данных на некоторых узлах, разделение сети на изолированные подсети, отключение некоторых узлов от сети) и выхода из строя некоторых узлов.

Работа состоит из содержания, введения, двух глав, заключения и списка использованных источников.



%%%%%%%%%%%%%%%%%
%%%% ГЛАВА 1 %%%%
%%%%%%%%%%%%%%%%%


\section{Алгоритмы консенсуса в распределённых системах}

	% 1.0 "Распределённые системы"
	\subsection{Распределённые системы}
	Когда мы говорим о распределённых алгоритмов, мы подразумеваем, что это алгоритмы для распределённых систем.
	
\textbf{Распределённые системы} - это парадигма, согласно которой два или более компьютера (узла)  сообщаются между собой с целью достичь общего соглашения. Конечный пользователь видит соглашение как единую логическую платформу [13]. 

Каждый узел может быть определён как индивидуальный игрок в \\ распределённой системе. Все узлы способны отправлять и получать сообщения друг от друга. 

Существует несколько состояний надёжности передаваемой информации между узлами: узлы могут быть точны в отправке информации, неисправны, а также отправлять заведомо неверную информацию. Кроме поведения, узлы наделены собственной памятью и процессором. 

Узел, который был замечен в выставлении произвольной или заведомо неверной информации, называется \textbf{византийским узлом}, а проблема \\ организации взаимодействия между несколькими узлами, некоторые из которых могут быть неисправны, называется задачей византийских генералов (англ. Byzantine generals problem) или византийская задача отказоустойчивости (англ. Byzantine fault tolerance) [14]. Такое поведение узла может быть не только признаком неисправности, но также и признаком злоумышленного поведения, которое может привести к неполадкам во всей распределённой сети. Таким образом, непредвиденное поведение узла в распределённой сети можно назвать \textbf{византийским}. 

	% 1.1 "Часы Лампорта"
	\subsection{Синхронизация узлов распределённой системы. Понятие логических часов. Часы Лампорта}
	
	Одно из фундаментальных понятий распределённых систем - это часы Лампорта. Распределённые системы состоят из множества отдельных процессов, которые упорядочены и разделены в пространстве, и которые могут сообщаться между собой с помощью обмена сообщениями.
	
Концепция времени фундаментальна для человеческого способа мышления. Она исходит от более базовой концепции упорядоченности событий. 

Мы говорим, что событие $a$ произошло раньше события $b$ в том случае, если на временной прямой, идущей слева направо событие $a$ находится строго левее события $b$. 

К сожалению, в распределённых системах невозможно определить, какое из двух событий произошло первым, если время задержки между сообщениями может быть больше, чем время между двумя последовательно возникающими событиями. Такое отношение как "произошло прежде" поэтому может лишь частично упорядочивать события в системе. 

Предположим, что система состоит из конечного набора процессов. Каждый процесс содержит последовательность событий. 

PICTURE 1

Предположим, что события в процессе такие, что событие $a$ произошло прежде события $b$. Также предположим, что отправка или получение сообщения - это события в процессе. Таким образом, мы можем определить отношение "произошло прежде" ($\Rightarrow$) как множество событий системы, удовлетворяющее  условиям [1]: 

1) Если $a$ и $b$ - события одного процесса, и $a$ произошло раньше $b$, тогда $a \Rightarrow b$. 

2) Если $a$ - это отправка сообщения от одного процесса к другому, и $b$ - это получение этого же сообщения другим процессом, тогда $a \Rightarrow b$.

3) Если $a \Rightarrow b$ и $b \Rightarrow c$, тогда $a \Rightarrow c$. Два процесса $a$ и $b$ называют параллельными, если $a \nRightarrow b$ и $b \nRightarrow a$.
 
На рисунке 1 вертикаль моделирует время: более позднее событие находится выше более раннего. Точки определяют события, вертикальные прямые - процессы. 

Теперь добавим в систему логические часы (часы). Определим часы $C_i$ для каждого процесса $P_i$ как функцию с числами $C_i(a)$ для каждого события $a$ в этом процессе. Система часов представляет из себя функцию $C$, которая определяет для каждого события $b$ число $C(b)$, где $C(b) = C_j(b)$ в том случае, если $b$ - событие процесса $P_j$ [1].

\textbf{Условие для часов}: Для любого события $a, b$: если $a \Rightarrow b$, тогда $C(a) < C(b)$. 

\textbf{Условие 1}. Если $a$ и $b$ - события процесса $P_i$, и $a$ произошло прежде события $b$, тогда $C_i(a) < C_i(b)$.

\textbf{Условие 2}. Если $a$ - это отправка сообщения от процесса $P_i$, и $b$ - это получение того же сообщения процессом $P_j$, тогда $C_i(a) < C_j(b)$. 

PICTURE 2

Рассмотрим рисунок 2. На нём часы представлены в терминах \\ пространственно-временной диаграммы. Представим, что у каждого процесса есть атомарные тики, которые происходят между событиями процесса $P_i$ с $C_i(a) = 4$ и $C_i(b) = 7$. Тогда тики 5, 6 и 7 на часах происходят между двумя событиями. На рисунке 2 каждый тик изображён как пунктирная линия. 

Условие 1 означает, что здесь должен быть тик между двумя событиями в процессе.
 
Условие 2 означает, что каждая линия сообщений должна пересекать линию тика. 

Для того, чтобы гарантировать, что часы в системе удовлетворяют условиям, описанным выше (Условие 1 и Условие 2). 

Условие 1 можно считать достаточно простым: процессам необходимо лишь подчиняться правилам реализации [1]: 

\textbf{Правило реализации 1.} 

Каждый процесс $P_i$ увеличивает $C_i$ на 1 для каждого нового успешного события. 
Для описания следующего правила потребуем, чтобы каждое сообщение m содержало временную отметку $T_m$, которая эквивалентна времени, в которое сообщение было отправлено. 
Правило реализации 2. 

а) Если событие $a$ - это отправка  сообщения $m$ процессом $P_i$, тогда сообщение $m$ содержит временную отметку $T_m = C_i(a)$. 

б) Для любого процесса $P_j$ временная отметка $C_j$ получения сообщения $m$ больше либо равна $T_m$.

\textbf{Правило реализации 2.}
 
а) Если событие $a$ - это отправка  сообщения $m$ процессом $P_i$, тогда сообщение $m$ содержит временную отметку $T_m = C_i(a)$.
 
б) Для любого процесса $P_j$ временная отметка $C_j$ получения сообщения $m$ больше либо равна $T_m$.

С помощью условий и правил реализации логических часов мы смогли выяснить концепцию словосочетания "произошло прежде", которое определяет инвариант порядка сообщений в распределённой системе с несколькими \\ процессами. С точки зрения распределённых алгоритмов наиболее важным является факт относительной упорядоченности событий.


	% 1.2 "Понятие консенсуса"
	\subsection{Понятие консенсуса}

	В этой части мы рассмотрим проблему консенсуса [15]. Авторы работы "Распределённые системы: концепции и дизайн" [5] рассматривают консенсус как проблему \textit{соглашения}. 
	
\textbf{Модель системы}

Модель системы включает множество процессов $p_i (i = 1, 2, ..., N)$, \\ сообщающихся благодаря отправке сообщений. Важное требование: соглашение должно быть достигнуто даже при возможных ошибках, выходе из строя одного или нескольки процессов. Предположим,  что сообщение между процессами надёжное, но процессы всё ещё могут выйти из строя. Мы будем рассматривать Византийские сбои наравне с прочими. 


\textbf{Определение проблемы консенсуса} Для того, чтобы достичь консенсуса, каждый процесс $p_i$ в \textit{не принявший решений} состоянии \textit{предлагает} единственное значение $v_i$ из набора значений $D (i = 1, 2, ..., N)$. Процессы общаются друг с другом с помощью обмена значений. Каждый процесс устанавливает значение в \textit{переменную решения}, $d_i$. Это приводит к изменению состояния процесса на состояние \textit{принявшего решение}. На рисунке 3 изображен описанный процесс. Два процесса предлагают принять значение, третье предлагает отменить и затем выходит из строя. Два процесса решают продолжить. 

PICTURE 3 661

Условия для выполнения алгоритма консенсуса [5]: 

\textit{Прерывание}: Случай, когда для каждого процесса выставленно значение переменной решения. 

\textit{Соглашение}: Значение решения для всех корректно работающих процессов одно и то же: если $p_i$ и $p_j$ работают корректно и для них введены значения, то $d_i = d_j (i, j = 1, 2, ...,N)$.

\textit{Целостность}: Все корректные процессы предлагают одинаковое значение. То есть любой корректный процесс находится в состоянии \textit{принявшего решение} и выбрал одинаковое с другими значение.

В определении целостности могут встречаться вариации, согласно \\ приложению условия. К примеру, более слабый тип целостности может \\ предполагать, что \textit{переменную решения} приняло какое-то число процессов - не обязательно даже всех. Так же условие целостности могут называть условием \textit{доказанности}. 

Для того, чтобы сопоставить формулировку проблемы и алгоритм, \\ предположим систему, которая не может давать сбоев. Это в тот же самый момент решает консенсус. К примеру, мы можем объединить процессы в группы и реализовать надёжную широковещательную рассылку сразу всем остальным процессам в группе. Каждый процесс ждёт, пока он соберёт все $N$ значений со всех процессов (включая его самого). Это определяет функцию \textit{большинства}$(v_1, v_2, ..., v_N)$, которая возвращает значение наиболее частого аргумента или специальное значение $\perp \notin D$, если большинство не достигнуто. 

Прекращение гарантируется надёжностью рассылки. Соглашение и \\ целостность гаратируются благодаря опредлелению большинства и и целостности значения при рассылки. Каждый процесс получает одинаковый набор значений, каждый процесс использует одинаковый функционал для этих значений. Таким образом, все они находятся в соглашении, и, если каждый процесс предлагает одинаковое значение, они все решают установить его. 

Заметим, что функция большинства - единственный способ соглашения о значении между процессами. 

Если процессы могут выходить из строя, это может принести проблемы, и процесс принятия соглашения будет прерван. Как известно, часто для запуска процессов используются узлы в виде компьютеров, которые могут выходить из строя полностью или частично, и даже стать византийскими по стечению обстоятельств. 

Если процессы выходят из строя в случайном (возможно, византийском) порядке, то "поломанные" процессы могут сообщать случайные значения друг для друга. Это, конечно, выглядит неправдоподобно, что ошибка в системе может породить подобный алгоритм консенсуса, но с совершенно другими значениями. Несмотря на это, сбой может быть не случайными, но являться результатом злонамеренного умысла. Кто-то может выборочно изменить процессы, и заставить их отправлять новые данные на не вышедшие из строя узлы, в попытке расстроить достижение консенсуса. В случае неконсистентности, корректные процессы могут сравнить полученные значения с ожидаемыми. 

\textbf{Проблема византийских генералов}

В неформальном описании проблема византийских генералов  [15] звучит как: три или более генералов согласились атаковать или отступать. Один, коммандир, отдаёт приказ. Остальные, лейтенанты коммандира, должны решить, нужно атаковать или оступать. Но один или более генералов может быть "предателем". Если коммандир предатель, он предложет атаковать одному генералу и отступать другим. Если же один из лейтенантов предатель, он может сообщить одним, что коммандир приказал атаковать, а другим - что отступать. 

Проблема византийских генералов отличается от консенсуса в том, что отличающийся процесс подчиняется всем остальным, если они согласны на одном значении, вместо того чтобы каждому предлагать значение. 

\textit{Прерывание} Каждый случайный процесс создаёт его собственную переменную принятия решения. 

\textit{Соглашение} Переменная принятия решения одна для всех процессов: если $p_i$ и $p_j$ работают исправно, тогда состояние соглашения такое, что $d_i = d_j (i, j = 1, 2, ...,N)$.

\textit{Целостность} Если командир исправен, тогда все корректные процессы приходят к соглашению с тем, что командир предложил. 

Заметим, что для проблемы византийских генералов целостность \\  предполагает соглашение, когда командир исправен, но командир не обязан работать исправно. 


\subsection{Поняте кворума}
	

%%%%%%%%%%%%%%%%%
%%%% ГЛАВА 2 %%%%
%%%%%%%%%%%%%%%%%


\section{Алгоритмы консенсуса в распределённых системах}


% 1.3 "Алгоритмы консенсуса"
	\subsection{Алгоритмы консенсуса}

В данном разделе мы рассмотрим алгоритмы консенсуса, обозначим плюсы и минусы каждого из них [20]. 


\textbf{Доказательство работы (Proof of Work)} 

Этот алгоритм считается первым, и был представлен Сатоши Накамото [16] для создания распределённого консенсуса, который априори не доверяет узлам. Доказательство работы - не новая идея, но то, как Сатоши объединил уже сущетсвующие идеи (криптографические подписи, дерево хешей и одноранговые компьютерные сети peer-to-peer) в самодостаточную распределённую систему консенсуса, которая была достаточно инновационной для первого приложения криптовалют. 

Это работает так, что участники блокчейна должны решить \textbf{сложную, но бесполезную} вычислительную проблемы и добавить новую транзакцию как блок в блокчейн к другим. Аналогично с работниками шахт, которые получают ресурсы в процессе добычи (майнинг от англ. mining). Это сделано, чтобы удостовериться, что участники готовы тратить деньги и ресурсы (вычислительные мощности) на работу, то есть они не хотят нанести вред системе. Нанесение вреда ведёт к потере этих ресурсов, что должно нанести вред самим злоумышленникам.

Сложность проблемы может быть изменена в режиме реального времени, опираясь на постоянный промежуток времени для вычисления. Иногда может произойти ситуация, в которой один или более участников решают проблему в одно и то же время. В этом случае, участники должны выбрать цепочку действий, и самая долгая цепочка выигрывает. Так, предположим, что большая часть участников работает над одним вычислением. Тот участник, чьё вычисление вырастет быстрее и чья цепочка вычислений будет самой долгой, является доверительным. Вычисления безопасны до тех пор, пока более $50\%$ участников честны. 

\textit{Плюсы}:

\begin{itemize}
	\item Система активно тестируется с 2009 года и продолжает активно \\ использоваться по сей день.
\end{itemize}

\textit{Минусы:}

\begin{itemize}
	\item Скорость работы (алгоритм медленный);
	\item Тратит много ресурсов, что скажется на скорости выхода из строя компонентов;
	\item Подвержен эффекту масштабирования.
\end{itemize}

\textit{Используется в:} Bitcoin [17], Ethereum [18], Letecoin [19] и других. 

\textit{Тип:} консенсус с конкурированием.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\textbf{Доказательство доли владения (Proof of Stake)} 

Этот алгоритм принадлежит к алгоритмам соревнующегося консенсуса. Он был создан как альтернатива алгоритма доказательства работы, чтобы решить возникающие в нём проблемы. Здесь вместо того, чтобы использовать майнинг, участники должны иметь некоторую ставку, долю (монеты) в системе. Итак, если у участника есть $10\%$ монет, то вероятность майнинга в следующем блоке составит $10\%$. 

Майнинг требует больших вычислительных мощностей для выполнения различных криптографических вычислений, благодаря которым можно открыть новые вычислительные задачи. 

Вычислительная мощность выражается тратами на электроэнергию, на сами устройства, необходимые для подтверждения работы. Если же здоумышленник атакует систему, то он теряет свою ставку. Одна из проблем, которая может возникнуть - это проблема "ничего на кону", когда участникам вычислений нечего терять, они голосуют за множественные варианты цепочек блоков (вилки), тем самым предотвращая достижение консенсуса. Это изображено на рисунке 4.

PICTURE 4

В отличие от систем проверки работоспособности (где для расширения цепочки приходится выполнять много вычислений), работа с несколькими цепочками не требует больших затрат. Многие проекты пытались решить проблему "ничего на кону" по-разному, одним из решений является наказание тех, кто голосует за множественные вилки. 

\textit{Плюсы:}

\begin{itemize}
	\item Энергетически эффективный алгоритм;
	\item Каждая новая атака стоит дороже для злоумышленника;
	\item Не подвержен эффекту масштабирования.
\end{itemize}

\textit{Минусы:}

\begin{itemize}
	\item Подвержен эффекту "ничего на кону".
\end{itemize}

\textit{Используется в:} Ethereum (разрабатывается) [18], Peercoin [21] и других.   

\textit{Тип:} консенсус с конкурированием.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\textbf{Отложенное доказательство работы (Delayed Proof-of-Work)} 

Отложенное подтверждение работы - это гибрид консенсуса за счёт безопасности и вторичного хеширования. Консенсус достигается с помощью группы подтверждающих узлов, которые добавляют данные с первой цепочки во вторую, что потребует атаки на обе цепочки, чтобы разрушить хотя бы одну из них. 

Для работы сети вычислений можно использовать оба предыдущих алгоритма. Данный алгоритм присоединяется к любой желаемой цепочке алгоритма доказательство работы, как изображено на рисунке 5

PICTURE 5

В системе есть два типа узлов: подтверждающие (notary node) и обычные (common node, node). Подтверждающие узлы выбираются для уже согласованных узлов цепочки в присоеденённую цепь блоков. 

Чтобы предотвратить войны майнинга между подтверждающими узлами (которые могут снизить эффективность), для первого пользователя алгоритма, системы Komodo [22], был разработан метод майнинга с циклическим перебором, который работает в двух режимах. Режим "без подтверждения" позволяет всем сетевым узлам добывать блоки, аналогично традиционному алгоритму доказательство работы. Однако в режиме "активное подтверждение" сетевые подтверждающие узлы будут добывать со значительно меньшей степенью сложности. В рамках этой схемы главному подтверждающему узлу разрешено добывать один блок со своей текущей степенью сложности, в то время как другие подтверждающие узлы должны добывать блок со сложностью в 10 раз выше, а все обычные узлы - со сложностью в 100 раз выше. 

Это приводит к новой проблеме: большие различия между сложностю хешей подтверждающих узлов и обычных. 

\textit{Плюсы:}

\begin{itemize}
	\item Энергетически эффективный алгоритм;
	\item Повышенная безопасность;
	\item Повышение ценности некоторых блоков цепочки.
\end{itemize}

\textit{Минусы:}

\begin{itemize}
	\item Ограничение на тип алгоритмов, на которых может базироваться (только доказательство работы и доказательство доли владения).
\end{itemize}

\textit{Используется в:} Komodo [22], Blockchain [17].   

\textit{Тип:} консенсус с коллаборацией.

	% 1.4 Raft"
	\subsection{Raft}

Raft - это консенсусный алгоритм, разработанный как альтернатива Paxos . Он должен был быть более понятным, чем Paxos, посредством разделения логики, но он также формально доказал свою безопасность и предлагает некоторые дополнительные функции. Raft предлагает общий способ распределения конечного автомата по кластеру вычислительных систем, гарантируя, что каждый узел в кластере согласовывает одну и ту же серию переходов состояний. Он имеет ряд реализаций ссылок с открытым исходным кодом, с реализациями полной спецификации на Go , C ++ , Java и Scala .

Рафт достигает консенсуса через избранного лидера. Сервер в кластере является либо лидером, либо последователем , и может быть кандидатом в конкретном случае выборов (лидер недоступен). Лидер отвечает за репликацию логов подписчикам. Он регулярно информирует последователей о своем существовании, отправляя сообщение сердцебиения. У каждого последователя есть тайм-аут (обычно от 150 до 300 мс), в течение которого он ожидает сердцебиение от лидера. Таймаут сбрасывается при получении пульса. Если пульс не получен, последователь меняет свой статус на кандидата и начинает выборы лидера.
% Раздел "Заключение"
\conclusion

%Библиографический список, составленный вручную, без использования BibTeX
%
%\begin{thebibliography}{99}
%  \bibitem{Ione} Источник 1.
%  \bibitem{Itwo} Источник 2
%\end{thebibliography}

%Библиографический список, составленный с помощью BibTeX
%
\bibliographystyle{gost780uv}
\bibliography{thesis}

% Окончание основного документа и начало приложений
% Каждая последующая секция документа будет являться приложением
\appendix



\section{Листинг программы}\label{pril-1}


%[fontsize=\small, numbers=left, numbersep=2pt]{task.pl}
\end{document}
